<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的第一篇博客.md</title>
      <link href="/2021/06/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/06/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="1-根据目的来分"><a href="#1-根据目的来分" class="headerlink" title="1. 根据目的来分"></a>1. 根据目的来分</h4><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p><ol><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li></ol><h4 id="2-根据作用范围来分"><a href="#2-根据作用范围来分" class="headerlink" title="2. 根据作用范围来分"></a>2. 根据作用范围来分</h4><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p><ol><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ol><p>表 1 介绍了这 23 种设计模式的分类。</p><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类）适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例 原型 抽象工厂 建造者</td><td>代理 (对象）适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><h4 id="3-GoF的23种设计模式的功能"><a href="#3-GoF的23种设计模式的功能" class="headerlink" title="3. GoF的23种设计模式的功能"></a>3. GoF的23种设计模式的功能</h4><p>前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>UML（Unified Modeling Language，统一建模语言）是用来设计软件蓝图的可视化建模语言，是一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。</p><p>1997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。</p><p>UML 具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。</p><p>UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。</p><p>在这里大家可能会疑问，UML 明明是一种图形，为什么说是语言呢？</p><p>语言是包括文字和图形的，有很多内容文字是无法表达的。你见过建筑设计图纸吗？里面还不是很多图形，光用文字能表达清楚建筑设计吗？在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML 就是其中的一种标准，注意这可不是唯一标准，只是 UML 是大家比较推崇的一种标准而已。UML 并不是强制性标准，没有规定在软件开发中一定要用 UML，但是我们需要包括 UML 在内的各种标准，来提高我们软件开发的水平。</p><h2 id="基本构件"><a href="#基本构件" class="headerlink" title="基本构件"></a>基本构件</h2><p>UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML 提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系。</p><p><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z10944153K.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="UML基本构件图"></p><p>下面对上图中的构件进行说明。</p><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。</p><h4 id="1-结构事物"><a href="#1-结构事物" class="headerlink" title="1. 结构事物"></a>1. 结构事物</h4><p>结构事物是模型中的静态部分，用以呈现概念或实体的表现元素，如下表所示。</p><table><thead><tr><th>事物</th><th>解释</th><th>图例</th></tr></thead><tbody><tr><td>类（Class）</td><td>具有相同属性、方法、关系和语义的对象集合</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1100S62Y.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>接口（Interface）</td><td>指一个类或构件的一个服务的操作集合，它仅仅定义了一组操作的规范，并没有给出这组操作的具体实现</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1101120163.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>用例（User Case）</td><td>指对一组动作序列的描述，系统执行这些动作将产生一个对特定的参与者（Actor）有价值且可观察的结果</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1101355293.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>协作（Collaboration）</td><td>定义元素之间的相互作用</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1101541915.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>组件（Component）</td><td>描述物理系统的一部分</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1102250437.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>活动类（Active Class）</td><td>指对象有一个或多个进程或线程。活动类和类很相象，只是它的对象代表的元素的行为和其他元素是同时存在的</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1104602M2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>节点（Node）</td><td>定义为运行时存在的物理元素</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z11046434W.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr></tbody></table><h4 id="2-行为事物"><a href="#2-行为事物" class="headerlink" title="2. 行为事物"></a>2. 行为事物</h4><p>行为事物指 UML 模型中的动态部分，如下表所示。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>交互（Interaction）</td><td>包括一组元素之间的消息交换</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1105G5541.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr><tr><td>状态机（State Machine）</td><td>由一系列对象的状态组成</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1105K5108.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr></tbody></table><h4 id="3-分组事物"><a href="#3-分组事物" class="headerlink" title="3. 分组事物"></a>3. 分组事物</h4><p>目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中，如下表所示。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>包（Package）</td><td>UML中唯一的组织机制</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1105Z4P0.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr></tbody></table><h4 id="4-注释事物"><a href="#4-注释事物" class="headerlink" title="4. 注释事物"></a>4. 注释事物</h4><p>注释事物是解释 UML 模型元素的部分，如下表所示。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>注释（Note）</td><td>用于解析说明 UML 元素</td><td><img "" class="lazyload placeholder" data-original="http://c.biancheng.net/uploads/allimg/200901/5-200Z1110006149.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></td></tr></tbody></table><blockquote><p>关于 UML 中的关系，我们在《<a href="http://c.biancheng.net/view/8374.html">UML类图及类图之间的关系</a>》一节讲解。</p></blockquote><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），分别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。</p><table><thead><tr><th>图名称</th><th>解释</th></tr></thead><tbody><tr><td>类图（Class Diagrams）</td><td>用于定义系统中的类</td></tr><tr><td>对象图（Object Diagrams）</td><td>类图的一个实例，描述了系统在具体时间点上所包含的对象及各个对象之间的关系</td></tr><tr><td>构件图（Component Diagrams）</td><td>一种特殊的 UML 图，描述系统的静态实现视图</td></tr><tr><td>部署图（Deployment Diagrams）</td><td>定义系统中软硬件的物理体系结构</td></tr><tr><td>活动图（Activity Diagrams）</td><td>用来描述满足用例要求所要进行的活动及活动间的约束关系</td></tr><tr><td>状态图（State Chart Diagrams）</td><td>用来描述类的对象的所有可能的状态和时间发生时，状态的转移条件</td></tr><tr><td>用例图（Usecase Diagrams）</td><td>用来描述用户的需求，从用户的角度描述系统的功能，并指出各功能的执行者，强调谁在使用系统、系统为执行者完成哪些功能</td></tr><tr><td>时序图（Sequence Diagrams）</td><td>描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序，强调对象之间消息的发送顺序，同时显示对象之间的交互过程</td></tr><tr><td>协作图（Collaboration Diagrams）</td><td>描述对象之间的合作关系，更侧重向用户对象说明哪些对象有消息的传递</td></tr><tr><td>包图（Package Diagrams）</td><td>对构成系统的模型元素进行分组整理的图</td></tr><tr><td>组合结构图（Composite Structure Diagrams）</td><td>表示类或者构建内部结构的图</td></tr><tr><td>时间图（Timing Diagrams）</td><td>用来显示随时间变化，一个或多个元素的值或状态的更改，也显示时间控制事件之间的交互及管理它们的时间和期限约束</td></tr><tr><td>交互概览图（Interaction Overview Diagrams）</td><td>用活动图来表示多个交互之间的控制关系的图</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/18/hello-world/"/>
      <url>/2021/06/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
